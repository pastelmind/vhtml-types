// TODO: When releasing this to DefinitelyTyped, replace the following line with
// "Type definitions for XXX". Then delete this comment.
// -----------------------------------------------------------------------------
// vhtml 2.2.0 type definitions
// Project: https://github.com/developit/vhtml
// Definitions by: Yehyoung Kang <https://github.com/pastelmind/>

export = vhtml;

/**
 * Converts Hyperscript/JSX to a plain string.
 * @param name Element name
 * @param attrs Attributes
 * @param children Child elements
 */
declare function vhtml<T extends string>(
  name: T,
  attrs?: HtmlElementAttr<T> | null,
  ...children: any[]
): string;

/**
 * Converts Hyperscript/JSX to a plain string.
 * @param component Functional pseudo-component
 * @param attrs Attributes
 * @param children Child elements
 */
declare function vhtml<Props, Children extends any[]>(
  component: (props: Props & { children: Children }) => string,
  attrs?: Props | null,
  ...children: Children
): string;

/**
 * @internal
 * Attributes supported on HTML tags.
 * This type alias allows custom tags to have any attribute, while still
 * enforcing type-checks on known HTML attributes.
 *
 * Notes:
 *  - Because TypeScript forbids unknown tag names in JSX, custom string tags
 *    can be used only with hyperscript-style code.
 *  - There is no need to add `{ [attr: string]: any }` to known attributes,
 *    since TypeScript already supports arbitrary `data-*` attributes in JSX
 *    (see "Note" in https://www.typescriptlang.org/docs/handbook/jsx.html#attribute-type-checking)
 */
type HtmlElementAttr<
  Tag extends string
> = (Tag extends keyof JSX.IntrinsicElements
  ? JSX.IntrinsicElements[Tag]
  : {}) & {
  dangerouslySetInnerHTML?: { __html: string };
  [attr: string]: any;
};

/**
 * @internal
 * Empty mapped types (`Pick<{}, never>`) are almost identical to the empty
 * object type (`{}`). However, TypeScript seems to treat them differently for
 * the purposes of checking `JSX.LibraryManagedAttributes`.
 *
 * This type alias converts any empty-ish type to a plain empty object type, so
 * that we can work around said behavior.
 */
type SafeEmptyType<T> = {} extends T ? {} : T;

/**
 * @internal
 * Same as `Omit<T, K>` introduced in TypeScript 3.4.
 * Added here so that we can support older versions of TypeScript.
 */
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

/**
 * @internal
 * Type alias that transforms the type of `props.children` of a vhtml component
 * to a type that TypeScript expects.
 *
 * Currently, this supports:
 * - Empty components (no props.children)
 * - Empty components (props.children is an empty tuple)
 * - Components with exactly one child (props.children is a 1-length tuple)
 * - Components with exactly zero or one child
 * - Components with arbitrary number of children (props.children is an array)
 * - Forbidding components whose props.children is not an array
 */
type ComponentPropTransform<TComp, TProps> = SafeEmptyType<
  Omit<TProps, "children">
> &
  (TProps extends { children: [] }
    ? {}
    : TProps extends { children: [infer ChildType] }
    ? { children: ChildType }
    : TProps extends { children: [(infer ChildType)?] }
    ? { children?: ChildType }
    : TProps extends { children: Array<infer ChildrenType> }
    ? { children?: ChildrenType | ChildrenType[] }
    : TProps extends { children: any }
    ? never
    : {});

declare global {
  namespace JSX {
    type Element = string;

    // Enable component children type checks
    interface ElementChildrenAttribute {
      children: {};
    }

    type LibraryManagedAttributes<TComp, TProps> = ComponentPropTransform<
      TComp,
      TProps
    >;

    interface IntrinsicAttributes {
      // This property is not used by vhtml, but is required to enforce
      // type checking of function components that accept no children.
      //
      // To explain: TypeScript checks JSX attributes (and children,
      // apprently) as though they are object literal assignments for a
      // component's props.
      // The only information I could find about this behavior was this:
      //  - https://github.com/microsoft/TypeScript/issues/15463#issuecomment-299263157
      //
      // If this property did not exist, TypeScript would treat this
      // interface as the empty object type (`{}`). Since TypeScript
      // allows objects with arbitrary attributes to be assigned to the
      // empty object type, it would allow `{ children: any }` to be
      // passed to a component, even if the component was childless.
      // Defining this dummy property prevents this behavior, so that
      // passing children to a childless component would correctly cause a
      // type error.
      //
      // Note that other JSX frameworks like React do not need this hack
      // because they use actual intrinsic properties, such as `key`.
      __dummy_dont_use?: any;
    }

    // The following interfaces were generated by transforming large sections of
    // JSX type definitions in @types/react 17.0.0. Those type definitions were
    // produced by multiple contributors, including, but not limited to:
    //
    //                 AssureSign <http://www.assuresign.com>
    //                 Microsoft <https://microsoft.com>
    //                 John Reilly <https://github.com/johnnyreilly>
    //                 Benoit Benezech <https://github.com/bbenezech>
    //                 Patricio Zavolinsky <https://github.com/pzavolinsky>
    //                 Digiguru <https://github.com/digiguru>
    //                 Eric Anderson <https://github.com/ericanderson>
    //                 Dovydas Navickas <https://github.com/DovydasNavickas>
    //                 Josh Rutherford <https://github.com/theruther4d>
    //                 Guilherme Hübner <https://github.com/guilhermehubner>
    //                 Ferdy Budhidharma <https://github.com/ferdaber>
    //                 Johann Rakotoharisoa <https://github.com/jrakotoharisoa>
    //                 Olivier Pascal <https://github.com/pascaloliv>
    //                 Martin Hochel <https://github.com/hotell>
    //                 Frank Li <https://github.com/franklixuefei>
    //                 Jessica Franco <https://github.com/Jessidhia>
    //                 Saransh Kataria <https://github.com/saranshkataria>
    //                 Kanitkorn Sujautra <https://github.com/lukyth>
    //                 Sebastian Silbermann <https://github.com/eps1lon>
    //                 Kyle Scully <https://github.com/zieka>
    //                 Cong Zhang <https://github.com/dancerphil>
    //                 Dimitri Mitropoulos <https://github.com/dimitropoulos>
    //                 JongChan Choi <https://github.com/disjukr>
    //                 Victor Magalhães <https://github.com/vhfmag>
    //                 Dale Tan <https://github.com/hellatan>
    //
    // See https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts
    // for the up-to-date list of contributors to @types/react
  }
}
